class Solution {
    static final int MOD = 1_000_000_007;
    static final int MAX = 20000;

    long[] fact = new long[MAX];
    long[] invFact = new long[MAX];

    public Solution() {
        // Precompute factorials
        fact[0] = 1;
        for (int i = 1; i < MAX; i++)
            fact[i] = fact[i - 1] * i % MOD;

        // Fermat inverse factorial
        invFact[MAX - 1] = modInverse(fact[MAX - 1]);
        for (int i = MAX - 2; i >= 0; i--)
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
    }

    public int[] waysToFillArray(int[][] queries) {
        int[] res = new int[queries.length];

        for (int i = 0; i < queries.length; i++) {
            int n = queries[i][0];
            int k = queries[i][1];

            long ans = 1;

            for (int p = 2; p * p <= k; p++) {
                if (k % p == 0) {
                    int count = 0;
                    while (k % p == 0) {
                        k /= p;
                        count++;
                    }
                    ans = ans * comb(count + n - 1, count) % MOD;
                }
            }

            if (k > 1) {
                ans = ans * comb(n, 1) % MOD;
            }

            res[i] = (int) ans;
        }

        return res;
    }

    private long comb(int n, int r) {
        return fact[n] * invFact[r] % MOD * invFact[n - r] % MOD;
    }

    private long modInverse(long x) {
        return power(x, MOD - 2);
    }

    private long power(long x, long y) {
        long res = 1;
        x %= MOD;
        while (y > 0) {
            if ((y & 1) == 1)
                res = res * x % MOD;
            x = x * x % MOD;
            y >>= 1;
        }
        return res;
    }
}
